export type BaseEntity = {
	fields: Record<string, BaseFieldCustomType<any, any>> & { 'id': BaseIdField },
	oneToOneOwned: Record<string, OneToOneRelationOwned>,
	oneToOneInverse: Record<string, OneToOneRelationInverse>,
	manyToOne: Record<string, ManyToOneRelation>,
	oneToMany: Record<string, OneToManyRelation>,
};

export type NonStrictBaseEntity = {
	fields: Record<string, BaseFieldCustomType<any, any>> & { 'id': BaseIdField },
	oneToOneOwned?: Record<string, OneToOneRelationOwned>,
	oneToOneInverse?: Record<string, OneToOneRelationInverse>,
	manyToOne?: Record<string, ManyToOneRelation>,
	oneToMany?: Record<string, OneToManyRelation>,
};

export type BaseIdField = {
	nullableOnInput: true,
	nullableOnOutput: false,
	toType: (sqlInput: number) => string,
	fromType: (tsInput: string) => number,
};

export type BaseFieldCustomType<TS, SQL> = {
	toType: (sqlInput: SQL) => TS,
	fromType: (tsInput: TS) => SQL,
	nullableOnInput: boolean,
	nullableOnOutput: boolean,
};

type OneToOneRelationOwned = { entity: string, nullable: boolean, inverse?: never };
type ManyToOneRelation = { entity: string, nullable: boolean, inverse?: never };
type OneToOneRelationInverse = { entity: string, inverse: string, nullable: boolean };
type OneToManyRelation = { entity: string, inverse: string, nullable?: never };

export function defineEntity<const T extends NonStrictBaseEntity>(entity: T): {
	fields: T['fields'],
	oneToOneOwned: NonNullable<T['oneToOneOwned']>,
	oneToOneInverse: NonNullable<T['oneToOneInverse']>,
	manyToOne: NonNullable<T['manyToOne']>,
	oneToMany: NonNullable<T['oneToMany']>,
} {
	// It would be really nice to encode this in the type system, but that is a major PITA
	if ('relations' in entity && entity.relations != null) throw new Error('Entity should not have a `relations` property, use the appropriate relation type keys instead');
	return {
		...entity,
		fields: entity.fields,
		oneToOneOwned: entity.oneToOneOwned ?? {},
		oneToOneInverse: entity.oneToOneInverse ?? {},
		manyToOne: entity.manyToOne ?? {},
		oneToMany: entity.oneToMany ?? {},
		// manyToMany: entity.relations, // TODO
	} as const;
}

const defaultFieldTypes = {
	number: defineCustomField(false, (x: number) => x, (x: number) => x),
	string: defineCustomField(false, (x: string) => x, (x: string) => x),
	boolean: defineCustomField(false, (x: boolean) => x, (x: boolean) => x),
	Date: defineCustomField(false, (x: string) => new Date(x), (x: Date) => x.toISOString()),
	Json: defineCustomField(false, (x: any) => x, (x: any) => x),
} as const;

export function defineField<Null extends boolean, T extends keyof typeof defaultFieldTypes>(type: T, nullable: Null): Omit<typeof defaultFieldTypes[T], 'nullableOnInput' | 'nullableOnOutput'> & { nullableOnInput: Null, nullableOnOutput: Null } {
	return { ...defaultFieldTypes[type], nullableOnInput: nullable, nullableOnOutput: nullable } as const;
}

export function defineAutogeneratedField<T extends keyof typeof defaultFieldTypes>(type: T): Omit<typeof defaultFieldTypes[T], 'nullableOnInput' | 'nullableOnOutput'> & { nullableOnInput: true, nullableOnOutput: false } {
	return { ...defaultFieldTypes[type], nullableOnInput: true, nullableOnOutput: false } as const;
}

export function defineCustomField<Null extends boolean, ToType extends (x: any) => any, FromType extends (x: any) => any>(nullable: Null, toType: ToType, fromType: FromType) {
	return { nullableOnInput: nullable, nullableOnOutput: nullable, toType, fromType } as const;
}

export function defineIdField() {
	return { nullableOnInput: true, nullableOnOutput: false, toType: (x: number) => x.toString(), fromType: (x: string) => Number(x) } as const;
}