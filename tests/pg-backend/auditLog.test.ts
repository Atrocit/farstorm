import { describe, it, test, expect } from 'vitest';
import { Farstorm, defineAutogeneratedField, defineEntity, defineField, defineIdField, sql } from "../../src/main";

const TodoItemSpec = defineEntity({
	fields: {
		id: defineIdField(),
		createdAt: defineAutogeneratedField('Date'),
		description: defineField('string', false),
	},
} as const);

describe('Postgres: audit log functionality', () => {
	async function setup() {
		const entityDefinitions = {
			'TodoItem': TodoItemSpec,
		} as const;

		const db = new Farstorm({
			type: 'postgresql',
			host: process.env['DB_HOST'] ?? 'localhost',
			port: Number(process.env['DB_PORT'] ?? '5432'),
			username: process.env['DB_USERNAME'] ?? '',
			password: process.env['DB_PASSWORD'] ?? '',
			database: process.env['DB_NAME'] ?? '',
			appName: 'farstormTests',
			ssl: false,
			poolSize: 2,
		}, entityDefinitions);

		await db!.inTransaction(async ({ nativeQuery }) => {
			await nativeQuery(sql`begin;`);
			await nativeQuery(sql`drop table if exists "user", "todo_item", "audit_log" cascade;`);

			await nativeQuery(sql`
				create table "todo_item" (
					id bigserial primary key,
					created_at timestamptz not null default now(),
					description character varying not null
				)
			`);
			await nativeQuery(sql`
				create table "audit_log" (
					id bigserial primary key,
					timestamp timestamp with time zone not null,
					transaction_id bigint not null,
					"table" character varying not null,
					entity_id bigint not null,
					type character varying not null,
					diff jsonb not null,
					metadata jsonb not null
				);
			`);
		});

		await db.enableAuditLogging();

		return {
			db,
			cleanup: async () => {
				await db.inTransaction(async ({ nativeQuery }) => {
					await nativeQuery(sql`drop table if exists "user", "todo_item", "audit_log" cascade;`);
					await nativeQuery(sql`rollback;`);
				});
			},
		};
	}

	it('inserting should generate an audit log item', async () => {
		const { db, cleanup } = await setup();
		await db.inTransaction(async ({ nativeQuery, findOne, saveOne }) => {
			const todoItem = await saveOne('TodoItem', { description: 'Test', createdAt: new Date() });
			const auditLogs = await nativeQuery(sql`select * from audit_log order by id desc`);

			const auditLogInsert = auditLogs.find(al => al.table == 'todo_item' && al.type == 'INSERT' && al['entity_id'] == todoItem.id);
			expect(auditLogInsert).not.toBeUndefined();
			expect(auditLogInsert).not.toBeNull();

			// Make sure metadata is set
			expect(auditLogInsert['metadata']).toEqual({ actor: 'testrunner' });

			// Diffing functionality
			expect(auditLogInsert!['diff']['description']).toEqual({ old: null, new: 'Test' });
			expect(auditLogInsert!['diff']['id']['old']).toBeNull();
			expect(auditLogInsert!['diff']['id']['new']).not.toBeNull();
		}, {
			auditMetadata: {
				actor: 'testrunner',
			},
		});
		await cleanup();
	});

	it('updating should generate an audit log item', async () => {
		const { db, cleanup } = await setup();
		await db.inTransaction(async ({ nativeQuery, findOne, saveOne }) => {
			const todoItem = await saveOne('TodoItem', { description: 'Test', createdAt: new Date() });
			const todoItem2 = await saveOne('TodoItem', { ...todoItem, description: 'Test Updated' });
			const auditLogs = await nativeQuery(sql`select * from audit_log order by id desc`);

			const auditLogUpdate = auditLogs.find(al => al.table == 'todo_item' && al.type == 'UPDATE' && al['entity_id'] == todoItem.id);
			expect(auditLogUpdate).not.toBeUndefined();
			expect(auditLogUpdate).not.toBeNull();

			// Make sure metadata is set
			expect(auditLogUpdate['metadata']).toEqual({ actor: 'testrunner' });

			// Diffing functionality
			expect(auditLogUpdate!['diff']).toEqual({ description: { old: 'Test', new: 'Test Updated' } });
		}, {
			auditMetadata: {
				actor: 'testrunner',
			},
		});
		await cleanup();
	});

	it('deleting should generate an audit log item', async () => {
		const { db, cleanup } = await setup();
		await db.inTransaction(async ({ nativeQuery, findOne, saveOne, deleteByIds }) => {
			const todoItem = await saveOne('TodoItem', { description: 'Test' });
			await deleteByIds('TodoItem', [ todoItem.id ]);

			const auditLogs = await nativeQuery(sql`select * from audit_log order by id desc`);

			const auditLogDelete = auditLogs.find(al => al.table == 'todo_item' && al.type == 'DELETE' && al['entity_id'] == todoItem.id);
			expect(auditLogDelete).not.toBeUndefined();
			expect(auditLogDelete).not.toBeNull();

			// Make sure metadata is set
			expect(auditLogDelete['metadata']).toEqual({ actor: 'testrunner' });

			// Diffing functionality
			expect(auditLogDelete!['diff']['description']).toEqual({ old: 'Test', new: null });
			expect(auditLogDelete!['diff']['id']['new']).toBeNull();
			expect(auditLogDelete!['diff']['created_at']['new']).toBeNull();
		}, {
			auditMetadata: {
				actor: 'testrunner',
			},
		});
		await cleanup();
	});

	it('noop should generate an empty audit log item', async () => {
		const { db, cleanup } = await setup();
		await db.inTransaction(async ({ nativeQuery, findOne, saveOne, deleteByIds }) => {
			const todoItem = await saveOne('TodoItem', { description: 'Test', createdAt: new Date() });
			await saveOne('TodoItem', { ...todoItem });

			const auditLogs = await nativeQuery(sql`select * from audit_log order by id desc`);

			const auditLogUpdate = auditLogs.find(al => al.table == 'todo_item' && al.type == 'UPDATE' && al['entity_id'] == todoItem.id);
			expect(auditLogUpdate).not.toBeUndefined();
			expect(auditLogUpdate).not.toBeNull();

			// Make sure metadata is set
			expect(auditLogUpdate['metadata']).toEqual({ actor: 'testrunner' });

			// Diffing functionality
			expect(auditLogUpdate!['diff']).not.toBeNull();
			expect(auditLogUpdate!['diff']).toEqual({});
		}, {
			auditMetadata: {
				actor: 'testrunner',
			},
		});
		await cleanup();
	});
});
