import { describe, it, test, expect } from 'vitest';
import { defineAutogeneratedField, defineEntity, defineField, defineIdField } from '../../src/entities/BaseEntity';
import { Farstorm, sql } from '../../src/main';

const TodoItemSpec = defineEntity({
	fields: {
		id: defineIdField(),
		createdAt: defineAutogeneratedField('Date'),
		createdAt2: defineAutogeneratedField('Date'),
		timesViewed: defineField('number', false),
		chanceOfSuccess: defineField('number', false),
		description: defineField('string', false),
	},
} as const);

describe('PGLite: field types', () => {
	async function setup() {
		const db = new Farstorm({
			type: 'pglite',
		}, {
			'TodoItem': TodoItemSpec,
		});

		await db!.inTransaction(async ({ nativeQuery }) => {
			await nativeQuery(sql`begin;`);
			await nativeQuery(sql`drop table if exists "user", "todo_item" cascade;`);

			await nativeQuery(sql`
				create table "todo_item" (
					id bigserial primary key,
					created_at timestamptz not null default now(),
					created_at2 timestamp not null default now(),
					times_viewed bigint not null,
					chance_of_success decimal(4, 2) not null,
					description character varying not null
				);
			`);
		});

		return {
			db,
			cleanup: async () => {
				await db.inTransaction(async ({ nativeQuery }) => {
					await nativeQuery(sql`drop table if exists "user", "todo_item" cascade;`);
					await nativeQuery(sql`rollback;`);
				});
			},
		};
	}

	it('timestamptz field should return JS Date object', async () => {
		const { db, cleanup } = await setup();
		await db.inTransaction(async ({ findOne, saveOne }) => {
			const todoItem = await saveOne('TodoItem', { description: 'Test', timesViewed: 1, chanceOfSuccess: 0.5 });
			const fetchedTodoItem = await findOne('TodoItem', todoItem.id);
			expect(fetchedTodoItem.createdAt).toBeInstanceOf(Date);
		});
		await cleanup();
	});

	it('timestamp field should return JS Date object', async () => {
		const { db, cleanup } = await setup();
		await db.inTransaction(async ({ findOne, saveOne }) => {
			const todoItem = await saveOne('TodoItem', { description: 'Test', timesViewed: 1, chanceOfSuccess: 0.5 });
			const fetchedTodoItem = await findOne('TodoItem', todoItem.id);
			expect(fetchedTodoItem.createdAt2).toBeInstanceOf(Date);
		});
		await cleanup();
	});

	it('ID field should return string', async () => {
		const { db, cleanup } = await setup();
		await db.inTransaction(async ({ findOne, saveOne }) => {
			const todoItem = await saveOne('TodoItem', { description: 'Test', timesViewed: 1, chanceOfSuccess: 0.5 });
			const fetchedTodoItem = await findOne('TodoItem', todoItem.id);
			expect(typeof fetchedTodoItem.id).toBe('string');
		});
		await cleanup();
	});

	it('Other bigint fields than ID should return as a number', async () => {
		const { db, cleanup } = await setup();
		await db.inTransaction(async ({ findOne, saveOne }) => {
			const todoItem = await saveOne('TodoItem', { description: 'Test', timesViewed: 1, chanceOfSuccess: 0.5 });
			const fetchedTodoItem = await findOne('TodoItem', todoItem.id);
			expect(typeof fetchedTodoItem.timesViewed).toBe('number');
			expect(fetchedTodoItem.timesViewed).toBe(1);
		});
		await cleanup();
	});


	it('Decimal fields should return as a JS floating point number', async () => {
		const { db, cleanup } = await setup();
		await db.inTransaction(async ({ findOne, saveOne }) => {
			const todoItem = await saveOne('TodoItem', { description: 'Test', timesViewed: 1, chanceOfSuccess: 0.5 });
			const fetchedTodoItem = await findOne('TodoItem', todoItem.id);
			expect(typeof fetchedTodoItem.chanceOfSuccess).toBe('number');
			expect(fetchedTodoItem.chanceOfSuccess).toBe(0.5);
		});
		await cleanup();
	});
});
